import streamlit as st
import json
from system_info import collect_system_data
from llm_interface import query_llm
from datetime import datetime
from utils import save_report_as_pdf, archive_old_reports, schedule_task, delete_scheduled_task, run_runbook, get_scheduled_jobs
from apscheduler.schedulers.background import BackgroundScheduler

# Set up Streamlit app configuration
st.set_page_config(page_title="System Debugger", layout="wide")
st.title("üõ†Ô∏è Lightweight System Debugger")

# Initialize the scheduler
scheduler = BackgroundScheduler()
scheduler.start()

# Initialize session state variables
if "report" not in st.session_state:
    st.session_state.report = None
if "data" not in st.session_state:
    st.session_state.data = None

def generate_report():
    """
    Collect system data, query the LLM, and return the generated report.
    """
    try:
        # Collect fresh system data
        print("Collecting system data...")
        system_data = collect_system_data()
        st.session_state.data = system_data

        # Generate a new report using the LLM
        report_prompt = f"""
Analyze the following system snapshot generated by psutil python. Use only this data and find out top 1-2 critical problems where we see abnormal observation in values. Do not answer outside this data.

{json.dumps(system_data)}
"""
        print("Querying LLM for report generation...")
        report = query_llm(report_prompt)
        st.session_state.report = report
        print("Report generated successfully.")

        return report
    except Exception as e:
        st.error(f"Error generating report: {str(e)}")
        return None

def generate_and_save_report():
    """
    Generate a fresh report and save it as a PDF.
    """
    try:
        report = generate_report()
        if report:
            print("Saving report as PDF...")
            save_report_as_pdf(report)
            archive_old_reports()
            print("Report saved and old reports archived.")
    except Exception as e:
        print(f"Error in scheduled report generation: {str(e)}")

# Button to collect and analyze system information
if st.button("Collect and Analyze System Info"):
    with st.spinner("Collecting system info and generating report..."):
        st.session_state.report = generate_report()

# Sidebar for automation settings
st.sidebar.header("Automation Settings")

# Option to enable scheduled reports
if st.sidebar.checkbox("Enable Scheduled Reports"):
    interval_unit = st.sidebar.selectbox("Interval Unit", ["Minutes", "Hours", "Days"], index=0)
    interval_value = st.sidebar.number_input(f"Interval ({interval_unit.lower()})", min_value=1, value=1, step=1)

    if st.sidebar.button("Schedule Report"):
        try:
            interval_seconds = interval_value * 60 if interval_unit == "Minutes" else interval_value * 3600 if interval_unit == "Hours" else interval_value * 86400
            schedule_task(scheduler, generate_and_save_report, interval_seconds, job_id="report_scheduler")
            st.sidebar.success("Report scheduling enabled.")
        except Exception as e:
            st.sidebar.error(f"Error scheduling report: {str(e)}")

    if st.sidebar.button("Delete Schedule"):
        try:
            delete_scheduled_task(scheduler, job_id="report_scheduler")
            st.sidebar.success("Report scheduling disabled.")
        except Exception as e:
            st.sidebar.error(f"Error deleting schedule: {str(e)}")

    # Display current schedules
    st.sidebar.subheader("Current Schedules")
    try:
        jobs = get_scheduled_jobs(scheduler)
        if jobs:
            for job in jobs:
                st.sidebar.text(f"Job ID: {job.id}, Next Run: {job.next_run_time}")
        else:
            st.sidebar.text("No active schedules.")
    except Exception as e:
        st.sidebar.error(f"Error fetching schedules: {str(e)}")

# Option to export the report as a PDF
if st.session_state.report:
    if st.button("Export Report as PDF"):
        try:
            file_path = save_report_as_pdf(st.session_state.report)
            archive_old_reports()
            st.success(f"Report saved as PDF: {file_path}")
        except Exception as e:
            st.error(f"Error exporting report: {str(e)}")

# Sidebar for runbook automation
st.sidebar.header("Runbook Automation")
if st.sidebar.button("Run Runbook"):
    try:
        run_runbook()
        st.sidebar.success("Runbook executed.")
    except Exception as e:
        st.sidebar.error(f"Error executing runbook: {str(e)}")

# Display the system debug report
if st.session_state.report:
    st.subheader("System Debug Report")
    st.text_area("Report", st.session_state.report, height=300)
    st.download_button("Download Report", st.session_state.report, file_name=f"system_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt")

# Display raw system data
if st.session_state.data:
    with st.expander("üîç Raw System Data"):
        st.json(st.session_state.data)
